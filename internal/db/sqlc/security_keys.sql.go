// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: security_keys.sql

package sqlc

import (
	"context"
	"database/sql"
)

const countAllSecurityKeys = `-- name: CountAllSecurityKeys :one
SELECT COUNT(*) AS count FROM security_keys
`

// Count all security keys
func (q *Queries) CountAllSecurityKeys(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countAllSecurityKeysStmt, countAllSecurityKeys)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSecurityKeysByMethod = `-- name: CountSecurityKeysByMethod :one
SELECT COUNT(*) AS count FROM security_keys WHERE method = ?
`

// Count security keys of a specific method
func (q *Queries) CountSecurityKeysByMethod(ctx context.Context, method string) (int64, error) {
	row := q.queryRow(ctx, q.countSecurityKeysByMethodStmt, countSecurityKeysByMethod, method)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteSecurityKey = `-- name: DeleteSecurityKey :exec
DELETE FROM security_keys WHERE id = ?
`

// Delete a security key by ID
func (q *Queries) DeleteSecurityKey(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteSecurityKeyStmt, deleteSecurityKey, id)
	return err
}

const deleteSecurityKeysByMethod = `-- name: DeleteSecurityKeysByMethod :exec
DELETE FROM security_keys WHERE method = ?
`

// Delete all security keys of a specific method
func (q *Queries) DeleteSecurityKeysByMethod(ctx context.Context, method string) error {
	_, err := q.exec(ctx, q.deleteSecurityKeysByMethodStmt, deleteSecurityKeysByMethod, method)
	return err
}

const getSecurityKeyByID = `-- name: GetSecurityKeyByID :one
SELECT id, method, label, wrapped_master_key, metadata, created_at, last_used_at
FROM security_keys
WHERE id = ?
`

// Get a single security key by ID
func (q *Queries) GetSecurityKeyByID(ctx context.Context, id int64) (SecurityKey, error) {
	row := q.queryRow(ctx, q.getSecurityKeyByIDStmt, getSecurityKeyByID, id)
	var i SecurityKey
	err := row.Scan(
		&i.ID,
		&i.Method,
		&i.Label,
		&i.WrappedMasterKey,
		&i.Metadata,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const getSecurityKeysByMethod = `-- name: GetSecurityKeysByMethod :many
SELECT id, method, label, wrapped_master_key, metadata, created_at, last_used_at
FROM security_keys
WHERE method = ?
ORDER BY created_at ASC
`

// Get security keys filtered by method type
func (q *Queries) GetSecurityKeysByMethod(ctx context.Context, method string) ([]SecurityKey, error) {
	rows, err := q.query(ctx, q.getSecurityKeysByMethodStmt, getSecurityKeysByMethod, method)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SecurityKey
	for rows.Next() {
		var i SecurityKey
		if err := rows.Scan(
			&i.ID,
			&i.Method,
			&i.Label,
			&i.WrappedMasterKey,
			&i.Metadata,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasAnySecurityKeys = `-- name: HasAnySecurityKeys :one
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END AS has_keys FROM security_keys
`

// Check if any security keys exist
func (q *Queries) HasAnySecurityKeys(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.hasAnySecurityKeysStmt, hasAnySecurityKeys)
	var has_keys int64
	err := row.Scan(&has_keys)
	return has_keys, err
}

const insertSecurityKey = `-- name: InsertSecurityKey :one
INSERT INTO security_keys (method, label, wrapped_master_key, metadata)
VALUES (?, ?, ?, ?)
RETURNING id, method, label, wrapped_master_key, metadata, created_at, last_used_at
`

type InsertSecurityKeyParams struct {
	Method           string         `json:"method"`
	Label            string         `json:"label"`
	WrappedMasterKey []byte         `json:"wrapped_master_key"`
	Metadata         sql.NullString `json:"metadata"`
}

// Insert a new security key and return the created row
func (q *Queries) InsertSecurityKey(ctx context.Context, arg InsertSecurityKeyParams) (SecurityKey, error) {
	row := q.queryRow(ctx, q.insertSecurityKeyStmt, insertSecurityKey,
		arg.Method,
		arg.Label,
		arg.WrappedMasterKey,
		arg.Metadata,
	)
	var i SecurityKey
	err := row.Scan(
		&i.ID,
		&i.Method,
		&i.Label,
		&i.WrappedMasterKey,
		&i.Metadata,
		&i.CreatedAt,
		&i.LastUsedAt,
	)
	return i, err
}

const listSecurityKeys = `-- name: ListSecurityKeys :many
SELECT id, method, label, wrapped_master_key, metadata, created_at, last_used_at
FROM security_keys
ORDER BY created_at ASC
`

// List all security keys ordered by creation date
func (q *Queries) ListSecurityKeys(ctx context.Context) ([]SecurityKey, error) {
	rows, err := q.query(ctx, q.listSecurityKeysStmt, listSecurityKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SecurityKey
	for rows.Next() {
		var i SecurityKey
		if err := rows.Scan(
			&i.ID,
			&i.Method,
			&i.Label,
			&i.WrappedMasterKey,
			&i.Metadata,
			&i.CreatedAt,
			&i.LastUsedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSecurityKeyLastUsed = `-- name: UpdateSecurityKeyLastUsed :exec
UPDATE security_keys
SET last_used_at = unixepoch()
WHERE id = ?
`

// Update the last_used_at timestamp for a security key
func (q *Queries) UpdateSecurityKeyLastUsed(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.updateSecurityKeyLastUsedStmt, updateSecurityKeyLastUsed, id)
	return err
}

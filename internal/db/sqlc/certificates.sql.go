// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: certificates.sql

package sqlc

import (
	"context"
	"database/sql"
)

const activateCertificate = `-- name: ActivateCertificate :exec
UPDATE certificates
SET encrypted_private_key = pending_encrypted_private_key,
    certificate_pem = ?,
    pending_csr_pem = NULL,
    pending_encrypted_private_key = NULL,
    pending_note = NULL,
    expires_at = ?,
    last_modified = unixepoch('now')
WHERE hostname = ?
`

type ActivateCertificateParams struct {
	CertificatePem sql.NullString `json:"certificate_pem"`
	ExpiresAt      sql.NullInt64  `json:"expires_at"`
	Hostname       string         `json:"hostname"`
}

// Activate certificate after upload (unified for initial or renewal)
// Move pending key to active column, store certificate, clear pending columns
func (q *Queries) ActivateCertificate(ctx context.Context, arg ActivateCertificateParams) error {
	_, err := q.exec(ctx, q.activateCertificateStmt, activateCertificate, arg.CertificatePem, arg.ExpiresAt, arg.Hostname)
	return err
}

const certificateExists = `-- name: CertificateExists :one
SELECT CASE WHEN COUNT(*) > 0 THEN 1 ELSE 0 END AS cert_exists FROM certificates WHERE hostname = ?
`

// Check if certificate exists by hostname
func (q *Queries) CertificateExists(ctx context.Context, hostname string) (int64, error) {
	row := q.queryRow(ctx, q.certificateExistsStmt, certificateExists, hostname)
	var cert_exists int64
	err := row.Scan(&cert_exists)
	return cert_exists, err
}

const clearPendingCSR = `-- name: ClearPendingCSR :exec
UPDATE certificates
SET pending_csr_pem = NULL,
    pending_encrypted_private_key = NULL,
    pending_note = NULL,
    last_modified = unixepoch('now')
WHERE hostname = ?
`

// Clear pending CSR and pending key without deleting the certificate
func (q *Queries) ClearPendingCSR(ctx context.Context, hostname string) error {
	_, err := q.exec(ctx, q.clearPendingCSRStmt, clearPendingCSR, hostname)
	return err
}

const createCertificate = `-- name: CreateCertificate :exec
INSERT INTO certificates (
    hostname,
    encrypted_private_key,
    pending_encrypted_private_key,
    pending_csr_pem,
    certificate_pem,
    expires_at,
    note,
    pending_note,
    read_only
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateCertificateParams struct {
	Hostname                   string         `json:"hostname"`
	EncryptedPrivateKey        []byte         `json:"encrypted_private_key"`
	PendingEncryptedPrivateKey []byte         `json:"pending_encrypted_private_key"`
	PendingCsrPem              sql.NullString `json:"pending_csr_pem"`
	CertificatePem             sql.NullString `json:"certificate_pem"`
	ExpiresAt                  sql.NullInt64  `json:"expires_at"`
	Note                       sql.NullString `json:"note"`
	PendingNote                sql.NullString `json:"pending_note"`
	ReadOnly                   int64          `json:"read_only"`
}

// Create a new certificate entry with all fields
func (q *Queries) CreateCertificate(ctx context.Context, arg CreateCertificateParams) error {
	_, err := q.exec(ctx, q.createCertificateStmt, createCertificate,
		arg.Hostname,
		arg.EncryptedPrivateKey,
		arg.PendingEncryptedPrivateKey,
		arg.PendingCsrPem,
		arg.CertificatePem,
		arg.ExpiresAt,
		arg.Note,
		arg.PendingNote,
		arg.ReadOnly,
	)
	return err
}

const deleteAllCertificates = `-- name: DeleteAllCertificates :exec
DELETE FROM certificates
`

// Delete all certificates
func (q *Queries) DeleteAllCertificates(ctx context.Context) error {
	_, err := q.exec(ctx, q.deleteAllCertificatesStmt, deleteAllCertificates)
	return err
}

const deleteCertificate = `-- name: DeleteCertificate :exec
DELETE FROM certificates WHERE hostname = ?
`

// Delete a certificate
func (q *Queries) DeleteCertificate(ctx context.Context, hostname string) error {
	_, err := q.exec(ctx, q.deleteCertificateStmt, deleteCertificate, hostname)
	return err
}

const getCertificateByHostname = `-- name: GetCertificateByHostname :one
SELECT hostname, encrypted_private_key, pending_csr_pem, certificate_pem, pending_encrypted_private_key, created_at, expires_at, last_modified, note, pending_note, read_only FROM certificates WHERE hostname = ? LIMIT 1
`

// Get a certificate by hostname
func (q *Queries) GetCertificateByHostname(ctx context.Context, hostname string) (Certificate, error) {
	row := q.queryRow(ctx, q.getCertificateByHostnameStmt, getCertificateByHostname, hostname)
	var i Certificate
	err := row.Scan(
		&i.Hostname,
		&i.EncryptedPrivateKey,
		&i.PendingCsrPem,
		&i.CertificatePem,
		&i.PendingEncryptedPrivateKey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastModified,
		&i.Note,
		&i.PendingNote,
		&i.ReadOnly,
	)
	return i, err
}

const listAllCertificates = `-- name: ListAllCertificates :many
SELECT hostname, encrypted_private_key, pending_csr_pem, certificate_pem, pending_encrypted_private_key, created_at, expires_at, last_modified, note, pending_note, read_only FROM certificates
ORDER BY created_at DESC
`

// List all certificates ordered by creation date
func (q *Queries) ListAllCertificates(ctx context.Context) ([]Certificate, error) {
	rows, err := q.query(ctx, q.listAllCertificatesStmt, listAllCertificates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Certificate
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.Hostname,
			&i.EncryptedPrivateKey,
			&i.PendingCsrPem,
			&i.CertificatePem,
			&i.PendingEncryptedPrivateKey,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.LastModified,
			&i.Note,
			&i.PendingNote,
			&i.ReadOnly,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreCertificate = `-- name: RestoreCertificate :exec
INSERT INTO certificates (
    hostname,
    encrypted_private_key,
    pending_encrypted_private_key,
    pending_csr_pem,
    certificate_pem,
    created_at,
    expires_at,
    last_modified,
    note,
    pending_note,
    read_only
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(hostname) DO UPDATE SET
    encrypted_private_key = excluded.encrypted_private_key,
    pending_encrypted_private_key = excluded.pending_encrypted_private_key,
    pending_csr_pem = excluded.pending_csr_pem,
    certificate_pem = excluded.certificate_pem,
    expires_at = excluded.expires_at,
    last_modified = excluded.last_modified,
    note = excluded.note,
    pending_note = excluded.pending_note,
    read_only = excluded.read_only
`

type RestoreCertificateParams struct {
	Hostname                   string         `json:"hostname"`
	EncryptedPrivateKey        []byte         `json:"encrypted_private_key"`
	PendingEncryptedPrivateKey []byte         `json:"pending_encrypted_private_key"`
	PendingCsrPem              sql.NullString `json:"pending_csr_pem"`
	CertificatePem             sql.NullString `json:"certificate_pem"`
	CreatedAt                  int64          `json:"created_at"`
	ExpiresAt                  sql.NullInt64  `json:"expires_at"`
	LastModified               int64          `json:"last_modified"`
	Note                       sql.NullString `json:"note"`
	PendingNote                sql.NullString `json:"pending_note"`
	ReadOnly                   int64          `json:"read_only"`
}

// Restore a complete certificate from backup in a single operation
func (q *Queries) RestoreCertificate(ctx context.Context, arg RestoreCertificateParams) error {
	_, err := q.exec(ctx, q.restoreCertificateStmt, restoreCertificate,
		arg.Hostname,
		arg.EncryptedPrivateKey,
		arg.PendingEncryptedPrivateKey,
		arg.PendingCsrPem,
		arg.CertificatePem,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.LastModified,
		arg.Note,
		arg.PendingNote,
		arg.ReadOnly,
	)
	return err
}

const updateCertificateNote = `-- name: UpdateCertificateNote :exec
UPDATE certificates
SET note = ?,
    last_modified = unixepoch('now')
WHERE hostname = ?
`

type UpdateCertificateNoteParams struct {
	Note     sql.NullString `json:"note"`
	Hostname string         `json:"hostname"`
}

// Update the note field for a certificate
func (q *Queries) UpdateCertificateNote(ctx context.Context, arg UpdateCertificateNoteParams) error {
	_, err := q.exec(ctx, q.updateCertificateNoteStmt, updateCertificateNote, arg.Note, arg.Hostname)
	return err
}

const updateCertificateReadOnly = `-- name: UpdateCertificateReadOnly :exec
UPDATE certificates
SET read_only = ?,
    last_modified = unixepoch('now')
WHERE hostname = ?
`

type UpdateCertificateReadOnlyParams struct {
	ReadOnly int64  `json:"read_only"`
	Hostname string `json:"hostname"`
}

// Mark certificate as read-only
func (q *Queries) UpdateCertificateReadOnly(ctx context.Context, arg UpdateCertificateReadOnlyParams) error {
	_, err := q.exec(ctx, q.updateCertificateReadOnlyStmt, updateCertificateReadOnly, arg.ReadOnly, arg.Hostname)
	return err
}

const updatePendingCSR = `-- name: UpdatePendingCSR :exec
UPDATE certificates
SET pending_csr_pem = ?,
    pending_encrypted_private_key = ?,
    pending_note = ?,
    last_modified = unixepoch('now')
WHERE hostname = ?
`

type UpdatePendingCSRParams struct {
	PendingCsrPem              sql.NullString `json:"pending_csr_pem"`
	PendingEncryptedPrivateKey []byte         `json:"pending_encrypted_private_key"`
	PendingNote                sql.NullString `json:"pending_note"`
	Hostname                   string         `json:"hostname"`
}

// Store or update pending CSR and key (unified for initial generation or renewal)
func (q *Queries) UpdatePendingCSR(ctx context.Context, arg UpdatePendingCSRParams) error {
	_, err := q.exec(ctx, q.updatePendingCSRStmt, updatePendingCSR,
		arg.PendingCsrPem,
		arg.PendingEncryptedPrivateKey,
		arg.PendingNote,
		arg.Hostname,
	)
	return err
}

const updatePendingNote = `-- name: UpdatePendingNote :exec
UPDATE certificates
SET pending_note = ?,
    last_modified = unixepoch('now')
WHERE hostname = ?
`

type UpdatePendingNoteParams struct {
	PendingNote sql.NullString `json:"pending_note"`
	Hostname    string         `json:"hostname"`
}

// Update the pending note field
func (q *Queries) UpdatePendingNote(ctx context.Context, arg UpdatePendingNoteParams) error {
	_, err := q.exec(ctx, q.updatePendingNoteStmt, updatePendingNote, arg.PendingNote, arg.Hostname)
	return err
}
